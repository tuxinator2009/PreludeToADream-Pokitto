#pragma once

#include "Pokitto.h"
#include <File>
#include <cstring>

class DataPack
{
	public:
		struct PackedFile
		{
			inline void rewind() {pos = start;}
			inline void seek(uint32_t offset) {pos = start + offset;}
			inline bool atEnd() {return pos >= end;}
			inline uint32_t size() {return end - start;}
			uint32_t start;
			uint32_t end;
			uint32_t pos;
		};
		DataPack() {}
		~DataPack() {m_file.close();}
		bool open(const char *filePath)
		{
			m_file.openRO(filePath);
			return m_file.error == 0;
		}
		void close() {m_file.close();}
		bool getPackedFile(uint32_t hashValue, PackedFile *file)
		{
			FileHeader header;
			file->start = 0;
			file->end = 0;
			file->pos = 0;
			m_file.seek(0);
			do
			{
				m_file.read((void*)&header, sizeof(header));
				if (header.hash == hashValue)
				{
					file->start = header.start;
					file->pos = file->start;
					m_file.read((void*)&header, sizeof(header));
					file->end = header.start;
					return true;
				}
			} while (header.hash != 0xFFFFFFFF);
			return false;
		}
		uint32_t readBytes(PackedFile *file, void *buffer, uint32_t count)
		{
			uint32_t bytesRead = std::min(count, file->end - file->pos);
			m_file.seek(file->pos);
			m_file.read(buffer, bytesRead);
			file->pos += bytesRead;
			return bytesRead;
		}
		template<typename T> T readValue(PackedFile *file)
		{
			T value;
			m_file.seek(file->pos);
			m_file.read((void*)&value, sizeof(T));
			file->pos += sizeof(T);
			return value;
		}
		inline void readyRead(const PackedFile &file)
		{
			m_file.seek(file.pos);
		}
		inline uint32_t readyRead(uint32_t hashValue) //end is provided so that the autogenerated FIEL_ macros can be used
		{
			FileHeader header;
			uint32_t start, end;
			m_file.seek(0);
			do
			{
				m_file.read((void*)&header, sizeof(header));
				if (header.hash == hashValue)
				{
					start = header.start;
					m_file.read((void*)&header, sizeof(header));
					end = header.start;
					m_file.seek(start);
					return start - end;
				}
			} while (header.hash != 0xFFFFFFFF);
			return 0;
		}
		int getError() {return m_file.error;}
		inline File &getFile() {return m_file;}
		//The following constexpr hashing code was provided by @Pharap
		static constexpr uint32_t xorshift32(uint32_t value)
		{
			value ^= (value << 13);
			value ^= (value >> 17);
			value ^= (value << 5);
			return value;
		}
		template<std::size_t size>
		static constexpr std::uint32_t hash(const char (& string)[size])
		{
			return hash(string, size);
		}
		static constexpr std::uint32_t hash(const char block[], std::size_t size)
		{
			constexpr std::size_t resultSize = sizeof(std::uint32_t);
			
			std::uint32_t sum = static_cast<std::uint32_t>(size);
			
			for (std::size_t i = 0; i < size; i += resultSize)
			{
				std::uint32_t value = 0;
				
				for (std::size_t j = 0; j < resultSize; ++j)
				{
					value <<= 8;
					
					const size_t index = (i + j);
					
					if(index < size)
						value |= block[index];
				}
				
				sum = xorshift32(sum + value);
			}
			
			return sum;
		}
		//constexpr std::uint32_t operator ""_hash(const char * string, std::size_t size)
		//{
		//	return DataPack::hash(string, size);
		//}
	protected:
		struct FileHeader
		{
			uint32_t hash;
			uint32_t start;
		};
		File m_file;
};
